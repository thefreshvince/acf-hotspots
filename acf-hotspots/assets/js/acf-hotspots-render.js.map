{"version":3,"sources":["components/acf/_Hotspot.js","components/acf/input.js"],"names":["HotspotInput","$","getClass","sorted_item","context","collapsible","class_base","document","string","HotspotPoint","attributes","_classCallCheck","this","x","y","i","points","length","point","exists","class_point","_createClass","key","value","clone","point_events","spot_clone","cloneNode","clone_fields","clone_number","clone_title","l","field_name","getAttribute","replace","setAttribute","innerHTML","spot_clone_original","parentNode","appendChild","inputs","j","get_inputs_object","wrapper","handle_remove","point_element","createElement","classList","add","style","left","top","main_image","undefined","remove_button","e","preventDefault","_this","remove","splice","reposition","removeChild","containment","scroll","stop","self","offsetLeft","offsetWidth","offsetTop","offsetHeight","update_position","make_draggable","HotspotItem","$el","el","source_image","img_src","generate_spot_clone","init","existing_points","push","original","_this2","on","_this3","addEventListener","create_hotspot_point","offsetX","offsetY","confirm","width","height","accordion","to","header","start","event","ui","item","index","beforeStop","sort_points","watch_for_new_image","change_hotspot_image","listen_for_user_clicks","add_exisiting_points","sortabe","jQuery","acf","add_action","get_fields","type","each","postbox"],"mappings":"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","file":"acf-hotspots-render.js","sourcesContent":["/**\n *\n *\tHotspot Class\n *\n */\n\nvar HotspotInput = (function($){\n\n  let class_base = 'acf-hotspot';\n\n  class HotspotPoint {\n\n    /**\n     *  Construct the point\n     */\n    constructor (attributes) {\n      this.class_point    = class_base + '__point';\n      this.x              = attributes.x;\n      this.y              = attributes.y;\n      this.context \t\t\t\t= attributes.context;\n      this.i              = this.context.points.length;\n      this.point          = this.create_point(attributes.x,attributes.y);\n\n      if(!attributes.exists) {\n        this.create_inputs(attributes.x,attributes.y);\n      }\n\n      this.point_events();\n    }\n\n\n    /**\n     *  Creates the HTML inputs\n     */\n    create_inputs (x,y) {\n      let clone = this.context.spot_clone.cloneNode(true),\n          clone_fields = getClass(class_base + '__input', clone),\n          clone_number = this.i,\n          clone_title = getClass(class_base + '__label', clone)[0];\n\n      for (var i = 0, l = clone_fields.length; i < l; i++) {\n        let field_name = clone_fields[i].getAttribute('data-name').replace('!!N!!', clone_number);\n        clone_fields[i].setAttribute('name', field_name);\n      }\n\n      clone_title.innerHTML = clone_title.innerHTML.replace(/!!N!!/g, clone_number+1);\n\n      getClass(class_base + '__input--x', clone)[0].value = x;\n      getClass(class_base + '__input--y', clone)[0].value = y;\n\n      this.context.spot_clone_original.parentNode.appendChild(clone);\n\n      return this.get_inputs_object(clone);\n    }\n\n\n    /**\n     *  Handles repositioning of point and updating of its values\n     */\n    reposition (i) {\n      let inputs = this.inputs.inputs;\n      this.i = i;\n      this.point.parentNode.appendChild(this.point);\n      for (var j = 0, l = inputs.length; j < l; j++) {\n        inputs[j].setAttribute(\n          'name',\n          inputs[j].getAttribute('name').replace(\n            /points]\\[\\d+\\]\\[/,\n            'points][' + i + ']['\n          )\n        );\n      }\n    }\n\n\n    /**\n     *  Get inputs object\n     */\n    get_inputs_object (wrapper) {\n      this.inputs = {\n        wrapper: wrapper,\n        inputs: getClass(class_base + '__input', wrapper),\n        x: getClass(class_base + '__input--x', wrapper)[0],\n        y: getClass(class_base + '__input--y', wrapper)[0]\n      };\n      this.handle_remove();\n      return this.inputs;\n    }\n\n\n    /**\n     *  Creates the point's HTML\n     */\n    create_point (x,y) {\n\n      let point_element = document.createElement('div');\n      point_element.classList.add(this.class_point);\n      point_element.style.left = (x * 100) + '%';\n      point_element.style.top = (y * 100) + '%';\n\n      this.context.main_image.parentNode.appendChild(\n        point_element\n      );\n\n      return point_element;\n\n    }\n\n\n    /**\n     *  Updates the position values in the inputs\n     */\n    update_position(x,y) {\n      this.x = x;\n      this.y = y;\n      this.inputs.x.value = x;\n      this.inputs.y.value = y;\n      this.point.style.left = x*100 + '%';\n      this.point.style.top = y*100 + '%';\n    }\n\n\n    /**\n     *  handles the listener for the remove button\n     */\n    handle_remove() {\n      if(this.inputs.wrapper === undefined) return;\n      let remove_button = getClass('acf-hotspot__delete',this.inputs.wrapper)[0];\n      remove_button.addEventListener(\n        'click',\n        (e) => {\n          e.preventDefault()\n          this.remove()\n        }\n      )\n    }\n\n\n    /**\n     *  Removes this point\n     */\n    remove() {\n      if(confirm('Are you sure you would like to remove point #' + (this.i+1) + '? (this change will only persist if you save/update this post)')) {\n        let points = this.context.points;\n        points.splice(this.i, 1);\n        for (let i = 0, l = points.length; i < l; i++) {\n          points[i].reposition(i);\n        }\n        this.point.parentNode.removeChild(this.point);\n        this.inputs.wrapper.parentNode.removeChild(this.inputs.wrapper);\n        // TODO: Delete this instance\n      }\n    }\n\n\n    /**\n     *  Makes this point draggable on the image\n     */\n    make_draggable () {\n      let self = this,\n          main_image = this.context.main_image;\n      $( this.point ).draggable({\n        containment: 'parent',\n        scroll: false,\n        // start: function() {},\n        // drag: function() {},\n        stop: function(e) {\n          let x = self.point.offsetLeft / main_image.offsetWidth,\n              y = self.point.offsetTop / main_image.offsetHeight;\n          self.update_position(x,y);\n        }\n      });\n    }\n\n\n    /**\n     *  Point Events\n     */\n    point_events () {\n      // this.handle_remove();\n      this.make_draggable();\n    }\n\n  }\n\n  return class HotspotItem {\n\n    /**\n     *  What we need to run the class\n     */\n    constructor ($el) {\n      this.el \t\t\t\t\t  = $el;\n      this.source_image   = $('.' + class_base + '__upload .acf-image-uploader .view img', $el);\n      this.img_src        = '';\n      this.main_image     = getClass( class_base + '__image', this.el[0])[0];\n      this.points         = [];\n      this.spot_clone     = this.generate_spot_clone();\n      this.init();\n    }\n\n\n    /**\n     *  Adds existing points to item\n     */\n    add_exisiting_points() {\n      let existing_points = getClass(class_base + '__point-fields', this.el[0]);\n      for (let i = 0, l = existing_points.length; i < l; i++) {\n        let x = getClass(class_base + '__input--x', existing_points[i])[0].value,\n            y = getClass(class_base + '__input--y', existing_points[i])[0].value,\n            point = new HotspotPoint({\n              x: x,\n              y: y,\n              context: this,\n              exists: true\n            });\n        point.get_inputs_object(existing_points[i]);\n        this.points.push(point);\n      }\n    }\n\n\n    /**\n     *  Generates spot fields clone\n     */\n    generate_spot_clone() {\n      let original = getClass(class_base + '__clone-base', this.el[0])[0],\n          clone = original.cloneNode(true);\n      this.spot_clone_original = original;\n      clone.classList.remove(class_base + '__clone-base');\n      clone.classList.add(class_base + '__point-fields');\n      return clone;\n    }\n\n\n    /**\n     *  Changes the hotspot imagearea to reflect the uploaded image\n     */\n\n    change_hotspot_image() {\n      this.img_src = this.source_image[0].getAttribute('src');\n      this.img_src = this.img_src.replace(/-\\d+x\\d+\\./g,'.');\n      this.main_image.setAttribute('src', this.img_src);\n    }\n\n\n    /**\n     *  Upload Watcher\n     */\n\n    watch_for_new_image() {\n      this.source_image.on(\n        'load error',\n        () => this.change_hotspot_image()\n      );\n    }\n\n\n    /**\n     *  Listen for user clicks on image\n     */\n\n    listen_for_user_clicks() {\n      this.main_image.addEventListener(\n        'click',\n        e => this.create_hotspot_point(e.offsetX,e.offsetY)\n      );\n    }\n\n\n    /**\n     *  Creates a new hotspot\n     */\n\n    create_hotspot_point (x,y) {\n\n      if(!confirm('Are you sure you would like to create a new point?')) return;\n\n      let width = this.main_image.offsetWidth,\n          height = this.main_image.offsetHeight,\n          point = new HotspotPoint({\n            x: x/width,\n            y: y/height,\n            context: this\n          });\n\n      $( '.' + class_base + '__information', this.el ).accordion( \"refresh\" );\n\n      return this.points.push(point);\n\n    }\n\n    /**\n     *  Sorts all references to the given point\n     */\n    sort_points (from, to) {\n      this.points.splice(to, 0, this.points.splice(from, 1)[0]);\n      for (var i = 0, l = this.points.length; i < l; i++) {\n        this.points[i].reposition(i);\n      }\n    }\n\n    /**\n     *  Reorders the point information\n     */\n    sortabe() {\n      let self = this,\n          sorted_item = -1;\n      $( '.' + class_base + '__information', this.el )\n        .accordion({\n          collapsible: true,\n          header: '.' + class_base + '__label'\n        })\n        .sortable({\n          // revert: true,\n          handle: '.' + class_base + '__label',\n          start: function( event, ui ) {\n            sorted_item = ui.item.index();\n          },\n          beforeStop: function( event, ui ) {\n            if(sorted_item !== ui.item.index()) {\n              self.sort_points(sorted_item-1, ui.item.index()-1);\n            }\n            sorted_item = -1;\n          }\n        });\n    }\n\n\n    /**\n     *  Triggers necessary watchers and events\n     */\n\n    init() {\n      this.watch_for_new_image();\n      this.change_hotspot_image();\n      this.listen_for_user_clicks();\n      this.add_exisiting_points();\n      this.sortabe();\n    }\n\n  }\n\n  // Set helper functions:``\n  function getClass(string, context) {\n    if(context === undefined) context = document;\n    return context.getElementsByClassName(string);\n  }\n\n})(jQuery);\n","(function($){\n\n\t/**\n\t *\n\t *\tACF INIT STUFF\n\t *\n\t */\n\n\tif( typeof acf.add_action !== 'undefined' ) {\n\n\t\t/*\n\t\t*  ready append (ACF5)\n\t\t*\n\t\t*  These are 2 events which are fired during the page load\n\t\t*  ready = on page load similar to $(document).ready()\n\t\t*  append = on new DOM elements appended via repeater field\n\t\t*\n\t\t*  @type\tevent\n\t\t*  @date\t20/07/13\n\t\t*\n\t\t*  @param\t$el (jQuery selection) the jQuery element which contains the ACF fields\n\t\t*  @return\tn/a\n\t\t*/\n\n\t\tacf.add_action('ready append', function( $el ){\n\n\t\t\t// search $el for fields of type 'hotspots'\n\t\t\tacf.get_fields({ type : 'hotspots'}, $el)\n\t\t\t\t.each(function() { new HotspotInput( $(this) ) });\n\n\t\t});\n\n\n\t} else {\n\n\n\t\t/*\n\t\t*  acf/setup_fields (ACF4)\n\t\t*\n\t\t*  This event is triggered when ACF adds any new elements to the DOM.\n\t\t*\n\t\t*  @type\tfunction\n\t\t*  @since\t1.0.0\n\t\t*  @date\t01/01/12\n\t\t*\n\t\t*  @param\tevent\t\te: an event object. This can be ignored\n\t\t*  @param\tElement\t\tpostbox: An element which contains the new HTML\n\t\t*\n\t\t*  @return\tn/a\n\t\t*/\n\n\t\t$(document).on('acf/setup_fields', function(e, postbox){\n\n\t\t\t$(postbox).find('.field[data-field_type=\"hotspots\"]')\n\t\t\t\t.each(function() { new HotspotInput( $(this) ) });\n\n\t\t});\n\n\n\t}\n\n\n})(jQuery);\n"]}